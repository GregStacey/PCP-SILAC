function [model,holdoutSSE,ICs] = choosemodel_holdout(cleanchrom,MaxIter)

% Selects the number of Gaussians that best fits a single chromatogram.
%
% Model selection is done by generating a distribution of SSEs for each model type. The distribution
% of SSEs are generated by fitting each model many times on a subset of the data. This is a hold out
% analysis. These distributions are finally run through Nick's model selection algorithm to pick the
% model type. Each fit requires initial conditions (ICs, also called StartingPoints). These are
% generated by function gaussfitICs.m.
%
% Input:
%   cleanchrom: nx1 cleaned chromatogram, where n is the number of fractions.
%   maxIter: integer, the number of iterations to run the holdout analysis.
% Output:
%   model: structure with three fields.
%       model.Ngauss - integer from 1 to 5, which is the number of Gaussians for the best model
%       model.fo - fit options for the best model, including ICs
%       model.ft - fit type of the best model
%   holdoutSSE: 1x5 cell, where each element is a distribution SSE of length MaxIter.
%
% Adapted from Nichollas Scott's Gaus_build_24_1.m.
% Made by Greg Stacey on Nov 25 2015.



%% 0. Initialize

if nargin<1
  error('Must input a chromatogram.')
end

if nargin<2
  disp('    Setting number of iterations to 500...')
  MaxIter = 500;
end

[n1,n2] = size(cleanchrom);
if n1~=1 && n2~=1 || (n1==1 && n2==1)
  error('Chromatogram must be a 1-dimensional vector.')
end

% transform chromatogram into column vector if necessary
if n2>n1
  cleanchrom = cleanchrom';
end


%% Generate initial conditions for a fit

% Calculate ICs
ICs = gaussfitICs(cleanchrom);

% Define fit type
ft{1} = fittype('gauss1');
ft{2} = fittype('gauss2');
ft{3} = fittype('gauss3');
ft{4} = fittype('gauss4');
ft{5} = fittype('gauss5');

% Define fit options
fo{1} = fitoptions('method','NonlinearLeastSquares','Robust','off','Lower',[0.1 0.1 0.1]);
fo{2} = fitoptions('method','NonlinearLeastSquares','Robust','off','Lower',[0.1 0.1 0.1 0.1 0.1 0.1]);
fo{3} = fitoptions('method','NonlinearLeastSquares','Robust','off','Lower',[0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]);
fo{4} = fitoptions('method','NonlinearLeastSquares','Robust','off','Lower',[0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]);
fo{5} = fitoptions('method','NonlinearLeastSquares','Robust','off','Lower',[0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]);

% Include ICs in fit options
for ii=1:5
  set(fo{ii},'startpoint',ICs{ii});
end


%% Run holdout analysis to generate holdoutSSE

N = length(cleanchrom);
x = (1:N)';

% Fitting using crossvalidation, done via hold-out analysis
% where 10% of the curve is removed to check
% THIS BUILDS Output_SSE
holdoutSSE = cell(1,5);
for ii=1:5
  jj=0;
  holdoutSSE{ii} = zeros(1,MaxIter);
  while jj < MaxIter
    try %attempt the hold out analysis
      jj=jj+1;
      train = crossvalind('HoldOut',N, 0.1);
      curveFit = fit(x(train),cleanchrom(train),ft{ii},fo{ii});
      yhat = feval(curveFit,x);
      holdoutSSE{ii}(jj) =  sum((yhat - cleanchrom).^2);
    catch
      disp(['   holdoutSSE: error in fitting: model ' num2str(ii) ', iteration ' num2str(jj)])
      %if the crossvalidation process leads to an error repeat till
      %the required successful initrations have been done
      if jj>1 % this ensures  i = 1 will not be turned to 0
        jj=jj-1;
      end
    end
  end
end



%% Select the best model
% Follows the logic of Gaus_build_24_1.m

Median1= median(holdoutSSE{1});
Median2= median(holdoutSSE{2});
Median3= median(holdoutSSE{3});
Median4= median(holdoutSSE{4});
Median5= median(holdoutSSE{5});

TEST2_1 = Median1/Median2;
TEST2_2 = Median2/Median3;
TEST2_3 = Median3/Median4;
TEST2_4 = Median4/Median5;

if     Median1<5&&TEST2_1<4
  Ngauss = 1;
elseif Median2<5&&TEST2_2<4
  Ngauss = 2;
elseif Median3<5&&TEST2_3<4
  Ngauss = 3;
elseif Median4<5&&TEST2_4<4
  Ngauss = 4;
elseif Median5<2&&TEST2_4>4
  Ngauss = 5;
else
  Ngauss = 0;
end

model.Ngauss = Ngauss;
if Ngauss>0
  model.fo = fo{Ngauss};
  model.ft = ft{Ngauss};
else
  model.fo = [];
  model.ft = [];
end

